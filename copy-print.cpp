#include <cstdint>
#include <iostream>
#include <cstdlib>
#include<ctime>
#include <algorithm>

//При вычислении результата выражения адресной арифметики 
//(или «арифметики с указателями») компилятор всегда умножает целочисленный
// операнд на размер объекта, на который указывает указатель
using namespace std;
//библиотека stdlib алгоритмы
/*template<typename T>
void copy_array(const T *from,  T *to, size_t count)
{
    //for (auto i=0; i<count; i++)
    //    to[i]=from[i]; 

    while (count--)
        *to++= *from++; //разыменовываем указатель ,присваиваем значение from, потом увеличиваем указатель from и to и смотрят на элементы след индекса

} */

/*template<typename T>
void print_array(const T *parr, size_t count)
{    
    //for (auto i=0; i<count; i++)
    //    cout<<parr[i]<<" ";

    //cout<<endl;

    while(count--)
        cout<< *parr++<<' ';
    cout<<endl;

} */
/* Добавление единицы к указателю возвращает адрес памяти следующего объекта этого же 
типа данных. */

//int array[4] = { 5, 8, 6, 4 }; 
//Переменная array содержит адрес первого элемента массива, как если бы это был указатель
//array+1 адрес памяти указателя на массив + 1 (индекс 1)
//Добавление единицы к идентификатору массива приведет к возврату адреса памяти второго элемента (элемента под индексом 1) массива. 
//Массив (типа int[4]) неявно конвертируется в указатель (типа int *)
//Оператор * имеет более высокий приоритет, чем оператор +.
//array[n] — это то же самое, что и *(array + n), где n является целочисленным значением.
//Оператор sizeof — это унарный оператор, который вычисляет и возвращает размер определенной переменной или определенного типа данных в байтах. 
template<typename T>
int find_array(const T *where, size_t count) //size_t беззнаковое целое число.
// Является типом результата, возвращаемого оператором sizeof. Размер типа выбирается таким образом, чтобы в него можно было записать максимальный размер теоретически возможного массива любого типа.
//Например,на 32-битной системе size_t будет занимать 32-бита, на 64-битной - 64-бита. 
// Если представить всю память компьютера как массив, то size_t, это индекс этого массива. Соответственно, в 32-битных системах, он будет 32 бита, в 64-х - 64.
{
    T min=where[0];
    int ind_m=0;  
    
    if (count==0)
    {
        return ind_m;  
    }
    for(auto i=1; i<count; i++)
    {
        if (where[i]<min)
        {    
            min=where[i];
            ind_m=i;
        }

    }

    return ind_m;

}


//реализовать поиск минимума в заданном массиве: const T *where , size_t count
//Должна возвращать индекс найденного элемента (0 для пустого массива )

int main (int argc, char **argv)
{   
    srand(time(NULL));
    int arr[20],arr2[20];
    for (auto i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
        arr[i]=rand()%100;
    
    std::copy(arr,arr+ sizeof(arr)/sizeof(arr[0]),arr2);
    //copy_array(arr,arr2,sizeof(arr)/sizeof(arr[0]));
    auto f=[] (int n) {cout<<n<<' ';}; //лямба функция
    std::for_each(arr,arr+ sizeof(arr)/sizeof(arr[0]),f);
    cout<<endl;
    //print_array(arr,sizeof(arr)/sizeof(arr[0]));
    std::for_each(arr2,arr2+ sizeof(arr2)/sizeof(arr2[0]),f );
    cout<<endl;
    //print_array(arr2,sizeof(arr2)/sizeof(arr2[0]));

    int index_min=find_array(arr,sizeof(arr)/sizeof(arr[0]));

    cout<<index_min<<endl;

    return 0;
}

/* [](){}- лямбда функция или анонимная функция

int p=0;  пространство функции (контекст функции, от которой анонимная функция изолирована)
Поле capture clause [такие скобки] используется для того, чтобы предоставить (косвенно) лямбде доступ к переменным из окружающей области видимости, к которым она обычно не имеет доступ. Всё, что нам нужно для этого сделать, так это перечислить в поле capture clause объекты, к которым мы хотим получить доступ внутри лямбды

[&p](int a)
{
    p=5; 
}

auto f =[&p]() тип функции будет зависеть от типа возврата в самой функции (auto определит)
{
    p=5; 
}

f();

f-переменная типа auto, которой присвоена лямбда функция 

auto f=[]() будет типа int
{
    return 1;
};

auto q=f(); будет тоже типа int

argc (англ. «argument count» = «количество аргументов») — это целочисленный 
параметр, содержащий количество аргументов, переданных в программу. argc всегда 
будет как минимум один, так как первым аргументом всегда является имя самой 
программы. Каждый аргумент командной строки, который предоставляет пользователь,
 заставит argc увеличиться на единицу.

argv (англ. «argument values» = «значения аргументов») — это место, где хранятся 
фактические значения аргументов. argv -это массив строк C-style. Длиной этого массива является argc.

Аргументы командной строки — это необязательные строковые аргументы, передаваемые 
операционной системой в программу при её запуске. Программа может их использовать в
качестве входных данных, либо игнорировать. Подобно тому, как параметры одной 
функции предоставляют данные для параметров другой функции, так и аргументы командной 
строки предоставляют возможность людям или программам предоставлять входные данные 
для программы.
Нулевой параметр — это путь и имя текущей программы. Первый и второй и тд параметры здесь являются аргументами командной строки, которые мы передали.
*/
